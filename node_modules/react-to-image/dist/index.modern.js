import { useRef, useState, useCallback } from 'react';
import { toJpeg, toPng, toBlob, toPixelData, toCanvas, toSvg } from 'html-to-image';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var utils = {
  defaultDownloadImage: function defaultDownloadImage(_ref) {
    var _ref$fileName = _ref.fileName,
        fileName = _ref$fileName === void 0 ? 'download' : _ref$fileName,
        _ref$format = _ref.format,
        format = _ref$format === void 0 ? 'png' : _ref$format,
        data = _ref.data;
    var link = document.createElement('a');
    link.download = fileName + "." + format;
    link.href = data;
    link.click();
  }
};

function useToImage(_temp, callback) {
  var _ref = _temp === void 0 ? {} : _temp,
      ref = _ref.ref,
      _ref$pixelRatio = _ref.pixelRatio,
      pixelRatio = _ref$pixelRatio === void 0 ? 1 : _ref$pixelRatio,
      _ref$backgroundColor = _ref.backgroundColor,
      backgroundColor = _ref$backgroundColor === void 0 ? 'transparent' : _ref$backgroundColor,
      restOptions = _objectWithoutPropertiesLoose(_ref, ["ref", "pixelRatio", "backgroundColor"]);

  var baseRef = ref || useRef();

  var _useState = useState({
    isLoading: false,
    error: null
  }),
      state = _useState[0],
      setState = _useState[1];

  var setRef = useCallback(function (node) {
    if (baseRef.current || !node) {
      return null;
    } else if (node) {
      baseRef.current = node;
    }
  }, []);

  var defaultGetter = function defaultGetter(libFunc, stateKey, defaultFormat, defaultCallback) {
    if (defaultCallback === void 0) {
      defaultCallback = utils.defaultDownloadImage;
    }

    return function () {
      try {
        setState(_extends({}, state, {
          isLoading: true
        }));

        var _temp3 = _catch(function () {
          return Promise.resolve(libFunc(ref || (baseRef === null || baseRef === void 0 ? void 0 : baseRef.current), _extends({
            pixelRatio: pixelRatio,
            backgroundColor: backgroundColor
          }, restOptions))).then(function (output) {
            var _extends2;

            var newState = _extends({}, state, (_extends2 = {
              isLoading: false
            }, _extends2[stateKey] = output, _extends2));

            setState(newState);

            if (callback && typeof callback === 'function') {
              callback(_extends({}, newState, restOptions));
            } else {
              defaultCallback(_extends({
                format: defaultFormat,
                data: output
              }, newState, restOptions));
            }
          });
        }, function (e) {
          var newState = _extends({}, state, {
            isLoading: false,
            error: e
          });

          setState(newState);
        });

        return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };
  };

  return _extends({}, state, {
    ref: ref || setRef,
    getSvg: defaultGetter(toSvg, 'dataURL', 'svg'),
    getJpeg: defaultGetter(toJpeg, 'dataURL', 'jpeg'),
    getPng: defaultGetter(toPng, 'dataURL', 'png'),
    getBlob: defaultGetter(toBlob, 'dataURL', 'png'),
    getPixelData: defaultGetter(toPixelData, 'dataURL', 'svg'),
    getCanvas: defaultGetter(toCanvas, 'dataURL', 'svg')
  });
}

export { useToImage };
//# sourceMappingURL=index.modern.js.map
